# 程序设计思路

## 确定环境

- 确定平台：Windows，由于其稳定的编程环境和可视化的适配性，以及其完备又稳定的可视化框架。
- 确定语言：C++，方便的指针操作和基础STL库对基础数据结构的完美支持，以及本人对其的熟练度远高于其他语言。
- 确定框架：MFC是著名（当然也是非常古老）的可视化框架，基于Windows且不跨平台，免费，Visual Studio环境，需要Windows Toolkit环境，编写时使用dll将库直接写入exe即可很方便的使用该软件。

## 开始学习

- 学习完全来源于网络，在[MFC教程视频](https://www.bilibili.com/video/av20005978)和各博客中获取MFC基础知识，然后配合C++工程的基础知识即可完成整套代码的编写。
- 进行入门，先学习了MFC的非框架式编写，关于_WinMain的入口函数的学习，有关句柄的基础概念，在单文件的条件下使用CodeBlocks编写了测试使用的原始级别的界面，在显示上需要自己指定所有窗口和句柄的大小，调用系统函数对其颜色、字体大小、边框等进行控制。期间发现很多不可解内容比如默认使用的字体是原始的像素字体，显示页面不友好，还要自己计算相对位置，菜单界面等问题，故采用了框架式编写。
- 安装Visual Studio，由于本人Windows系统占用磁盘空间不太大导致期间多次达到磁盘峰值，不得不吐槽一句VS是真的太大了。
- 编写数据处理的基础部分，由于本人是现役ACM队员，写一些图的基础操作（Dijkstra最短路、Prim构造MST、DFS遍历图、邻接矩阵、邻接表等）还是比较轻松的。封装出了本工程的第一个类，使用的是Jetbrains的CLion进行调试和测试功能完整性，具体包括：
  - 使用邻接表构图，节点信息另外建立了一个MessageNode类
  - 在UnOrderedGraph类中大量使用STL，建立多个函数
    - UnOrderedGraph构造函数，接受参数为n->节点个数，m->边个数，edges->利用pair储存两端点及边长的边信息，node->使用MessageNode类构造的节点信息，用列表参数初始化邻接表和节点信息
    - neighbor函数，接受参数为当前节点编号，返回与当前节点有直接相连的边的点信息，借助邻接表直接返回一个当前点的邻接信息构成的向量即可
    - dfs函数，参数为起始点和终止点，本身只是给外部类调用的入口，实际上只是清空了原来储存搜索信息的变量，然后调用内部方法的接口，详细可见dfsNow方法，每当当前节点递归到终止点就进行一次记录，然后不断回溯，当然dfs返回的就是记录下来的数组，一些同学不会寻找所有路径建议看看dfsNow函数。
    - distance函数，参数为起始点和终止点，利用Dijkstra算法查找单源最短路，基础操作可参考他人博客或书籍（所有基础算法书甚至大学课本应该都有dijkstra，[推荐书单](http://verly-badcw.top:8010/index.php/archives/70/)）
    - MST函数，无传入参数，这部分（包括distance）其实比较困难，在于本课设要求其需要删除和添加节点，如果直接用记录的n作为遍历的总点数的问题，最后只好把n的意义改为现有的最大节点，然后节点编号默认初始化为-1表示不存在该节点才得以解决，算法就是基础的Prim（其实作为ACMer对Kruskal的实现更熟悉但是课设要求）。
    - insertNode等6个增删改操作，注意细节即可。
    - clear清空整张图。
    - getIdx，利用MessageNode中的Name信息查找它在node数组中真正的下标（索引index，所以函数名叫getIdx）。
    - toString，模仿java的函数名（，具体是序列化该图，便于在不同窗口中传参，一开始是没有这个函数的，后期由于C++的extern变量实在不好用才写了这个，反而是方便了文件读写。
    - dfs2，后来发现课设要求中有从一个起点无回路遍历整张图加的方法，和dfs类似。

## 编写图形界面

- 图形界面设计在.rc文件中，用VS即可打开编辑，具体操作在各个类中。

- 主要是拖拽的操作，然后就是建立类和变量，根据视频讲解其实比较简单，由于之前也做过安卓开发，他们对界面的操作其实类似，不过安卓更加复杂，但是唯一id标识的特性还在就可以随意操作了。主要使用了两个窗口，一个是主窗口Spot Infomation ManagerDlg，主要的句柄元件有：CTabCtrl、CDialogEx（InfoEditor，具体建立类的方法见视频讲解，用于读写文件）、CComboBox、CStatic、CEdit，另一个是查询窗口QueryDlg，基本全用了CEdit去填充界面异常简单而又清晰。

- Unicode问题：由于中文字符的问题我调试了很久，后来在博客里说工程配置中可以修改工程使用Unicode就直接用了，然后注意我后来所有的字符串都改成了MFC中适配的CString类，有个小知识点就是TEXT("xxx")就可以把xxx转换为CString类，当然u也可以，对于变量还是TEXT吧。

- InfoEditor具体方法编写：一个在于读写文件和内存，只要理清楚了关系就可以写好了，第一步是读文件到内存，在软件内的修改和增删并不改变文件本身（甚至说除了读写阶段文件本身已经处于关闭状态程序关闭了读写权限），然后点击保存按钮时才会去操作文件，正好使用序列化的方式把图的信息保存回去，注意是两个（点信息和边信息）
  - 确定信息格式点信息格式：每行一个点”a b c“，a为数字表示序号，b为名字，c为描述
  - 确定信息格式边信息格式：每行一条边”a b c“，a和b为字符串是点的名字，c是长度
  - 读写具体见InfoEditor几个按钮的方法，使用的也是由于一般C和C++的读写函数对中文适应性不友好直接采用了MFC专用读写函数。GetPathName函数可以调用系统的打开文件窗口还是比较好用的，界面也较为友好。
  - 读完文件直接处理到editor区就是内存，用户可以自己编写也可以使用右方的操作台进行修改，当然修改完我使用的方式是每次修改都序列化一次图信息并更改editor区（再强调一次editor区就是内存）
  - 写文件时直接把editor区的文件存回之前打开的文件，所以当时还处理了一下打开文件时保存文件的路径信息。

- 编辑框，没什么好说的但是在图形化时需要仔细调参，包括文件显示超过了当前窗口大小应该怎么办，这都是基础的UI设计需要注意的问题，一定仔细调参，我也不会前端所以完毕。

- 下拉菜单，自己看视频讲解，各种调参和初始化，还是比较麻烦的，还遇见了个奇葩问题就是当时的下拉菜单非常短只能显示出一个，所以查了很久，在博客里发现了原因。

- TabCtrl，主要是为了列表显示点信息（炫一点？），总之还是挺麻烦，感觉MFC对这些东西的封装很反人类，并不是我想象中的操作，根据index修改页面标题和切换之类的，都不是我想象中的样子，感觉是不完全的封装类，但是勉强能用。

- 列表信息，这个东西操作起来也有点难受？不过按照视频讲解的方式也可以大致解决问题

## 可视化界面和信息处理的对接

- 非常重要的一个点，而且说实话有点困难，要不是我之前写了序列化函数这个我大概还不能解决C++工程中不同类变量共享的问题，后来是每个类中都有那么一个变量，然后通过构造（其实MFC中有专门的初始化函数直接传参就行）互相传参，由于不同窗口使用了不同的类（本工程两个工程），所以C++工程的传参真的是个很艰难而且重要的部分，我之前的安卓工程可以使用多种方式比如java的枚举、数据库等方式传参，但是C++好像并不是那么方便是我没想到的。

- 最后要说的一点就是注意每次修改和更新要注意sync，这是软件设计中很重要的一部分，一个修改并不直接就是修改一个地方，而是全局的sync，细节要注意，我习惯于写一个refresh函数更新内存，每次操作就refresh一次还挺方便的。

## 关于测试和调试

- 由于VS的操作是工程上面有个解决方案，解决方案的下级才是工程，大大提升了我调试的方便程度，我只需要设置运行工程为现在编辑文件所在的工程，然后调试时对另外建的一个无用工程进行修改，然后查看效果就可以看到是否满足我的预期，其实包括做其他项目也是一样，对自己的操作不确定的时候新建一个看效果总是很重要的一点。

- 测试时确实出现了问题，我做了多次断点调试，大部分问题来源于增删点，所以其实增删这种操作真的交给数据库做比较符合人类思维，自己写的数据结构还是不足以处理离散而又有关联而又想要效率的操作，建议是改进成数据先调数据库，然后每次查比如最短路就处理出图，再进行图中的最短路查找。

## 小结

- 总体从学习MFC到编写完整个工程使用了三天（虽然三个下午都在打camp的比赛），后续增加、修改的功能不到一个小时（感谢告诉我课设细节要求不符问题的同学），还是挺累而且遇到挺多问题的，但是我坚持单人完成了任务也算是有些成就感了，另外用了两小时？写了个无bug、小黑框框但功能异常完整且不会暴毙的简易课设程序，给需要的同学一个参照（由于是单文件，用Vex.txt储存节点信息，Edge.txt储存边信息，格式与我这个可视化的一样，放置于该cpp同目录即可正常运行，当然是个很小的程序所以不包括异常处理所以出bug请自己看文件是不是写错了）。